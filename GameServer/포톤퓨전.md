## 포톤 퓨전2 - 데디케이트 서버
해당 문서는 포톤 퓨전2 입문자를 위해 작성되었습니다.
필자 또한 입문자이며, 틀린 부분이 있을 수 있으니 감안하여 읽어주시길 바랍니다. 만약 피드백이 있다면 편하게 남겨주시면 감사하겠습니다.

## 시작하기
포톤 퓨전2는 총 3종류의 네트워크 토폴로지가 존재합니다.

클라이언트끼리 소통하는 Share 모드,   
클라이언트 한 명이 서버가 되어 호스트하는 Host 모드,   
마지막으로 서버가 벼래로 존재하는 Server 모드

로 나뉩니다.

해당 문서에서는 Host모드(+Server 모드)를 중심으로 설명합니다.

## 기본 행동강령
1. 스크립트가 부착되는 오브젝트와 그래픽으로 보여지는 오브젝트 분리하기   
네트워크에서 사용할 오브젝트를 생성할 시에는 최상위 부모로 빈 객체를 두고, 해당 오브젝트에 네트워크 스크립트 및 기타 스크립트를 모두 부착합니다. 그리고 해당 객체의 자식으로 그래픽 오브젝트를 둡니다.

## 포톤 퓨전 핵심 기술

퓨전은 틱 기반 상태 동기화 라이브러리이다.

즉, 모든 클라이언트에서의 상태를 동기화 시키는 것을 목적으로 한다.

### 예측
서버 - 클라이언트 사이에는 항상 지연이 존재함.   
그렇다고 서버의 데이터만을 받아서 클라이언트를 업데이트 하자니 뚝 뚝 끊기게 됨.   
-> 클라이언트에서 예측을 이용해 그 공백을 채우자

* FixedUpdateNetwork()   
유니티의 FixedUpdate와 거의 동일한 개념.

1. 서버에서는 유니티의 FixedUpdate와 완전히 동일하게 작동.
균일한 시간 간격의 틱마다 매번 FixedUpdateNetwork를 실행시킴. 그리고 한 틱이 끝나면 변경된 모든 정보를 브로드캐스트 함.

2. 클라이언트에서는 예측을 위해 자신의 입력을 기반으로 FixedUpdate를 여러번 실행시킴.

-> 솔직히 잘 이해 못함; 하면서 발생하는 문제들 마주하면서 봐야 제대로 이해 될 듯 함.

생각한 것보다 FixedUpdateNetwork의 속도가 느린 것 같은데, 당연한 수순이라고 생각한다. FixedUpdate는 원래 Update보다 틱이 느렸던 것으로 기억하는데(테스트 시에) 여기다 서버와의 딜레이, 패킷 전송 등을 고려하면 더 느릴 수도 있을 것 같다.

### 프라퍼티 상태 동기화(네트워크화된 속성)

스크립트 내 프라퍼티의 값을 일치시킬 수 있다.

* [Networked]   
애트리뷰트를 이용하면 NetworkTransform에서 Transform을 동기화시키듯 모든 클라이언트에서 프라퍼티 값을 일치시킬 수 있다.

단, 권한이 없는 객체에 네트워크 프라퍼티 값을 변경하는 것은 의미없다. (다음 틱에 서버에 의해 원래 값으로 재정의된다. )

### RPC
클라이언트 결합을 위해 사용됨. 일반 메소드에 대한 직관적인 매핑.

서로 다른 클라이언트에서 서로 다른 시간에 실행됨(특정 틱에 의존되어있지 않음)
-> 수신받지 못했을 경우 그대로 해당 클라이언트에서는 증발

즉, 네트워크 상태(틱에 의존)에 결합되어있지 않음.
= RPC는 메인 게임 로직에 사용하면 위험함.
= 굳이 틱으로 정밀하게 관리할 필요가 없을 경우 유용하게 사용할 수 있음.
= 모든 플레이어가 아닌 한 플레이어에게만 연관이 있을 경우 유용함.

1. 플레이어 메시지 전송
2. 상점에서 구매
3. 플레이어 정보 입력

RPC는 각 플레이어에서 네트워크로 직접 보내는 것이기 때문에 Fusion 입력 처리를 사용할 필요가 없다.
(=Input을 단순히 유니티 입력 처리 방식(로컬)으로 해도 무방하다. )

호스트 모드에서 Rpc는
클라이언트 -> 호스트
호스트 -> 모든 클라이언트
와 같이 두개의 RPC를 만들어야 한다.
(자세한 예시는 튜토 6번 원격 프러시저 호출 참고)

### NetworkBehaviour

NetworkBehaviour은 Fusion에 포함된 네트워크 기능들(네트워크화된 속성, RPC)를 사용할 수 있도록 하는 클래스이다. MonoBehaviour의 퓨전 버전이라고 생각하면 편하다. 단, NetworkBehaviour을 상속받은 스크립트를 부착한 오브젝트는 반드시 NetworkObject를 상속받아야 한다. (네트워크화된 오브젝트를 다루니 당연한 일이다. )

스크립트를 직접 확인할 수 없도록 되어 있지만(어셈블리화 되어 있음) 아마 MonoBehaviour를 상속받은 것 같다. 정상적으로 라이프 사이클을 사용할 수 있다.

### SimulationBehaviour

SimulationBehaviour은 네트워크 오브젝트로 사용하지 않을 것이나, Fusion의 콜백을 받아야 할 때 사용한다. 즉, 부착할 오브젝트가 NetworkObject를 상속받지 않을 예정임에도(=상태 동기화가 필요하지 않음에도) Fusion 콜백을 받아야 할 경우.

### NetworkTransform?

### NetworkRunner?

INetworkRunnerInterfaces를 상속받음으로 OnPlayerLeft와 같은 콜백을 사용할 수 있다.

### StateAuthority/InputAuthority 등 권한 관리

기본적으로 특정 플레이어는 서버에 의해 스폰된다. 그리고 해당 플레이어의 라이프 사이클은 모든 클라이언트에 의해 동작한다. (모든 클라이언트에 해당 플레이어가 존재하기 때문. ) 따라서 InputAuthority에 의해 해당 플레이어에 입력 권한이 있는 사용자만 입력을 처리할 수 있게 해야 한다.

State Authority는 서버를 확인하기 위함.

즉, 전부 권한 확인을 위해서이다. 권한이 없는 곳에서 기능이 실행되지 않도록 확인할 수 있게 만들어준다.



## 포톤 퓨전 기타 기술

### NetworkButtons

버튼의 입력 상태 추적에 도움을 주는 Fusion 타입.
인풋 처리 시 사용.

### 연타 처리
Update()를 이용해 사전에 연타 기록을 받아두고 다음 틱에 보내는 방식도 가능하다.
(튜토리얼 - 예측 참고)

### Spawn()은 인스턴스 생성 이후 동기화 전 호출
이를 이용하여 Spawn에 콜백을 넣어 동기화 전에 함수가 호출되도록 할 수 있다. 일종의 Awake() 느낌.

### 메인 로직과 다른 부차적 로직(ex. 볼 발사 시 플레이어 색 변화) - ChangeDetector

ChangeDetector 는 네트워크화된 속성 값의 변경사항을 확인하는 용도로 사용된다.

foreach -> changeDetector.DetectChanges를 이용하면 네트워크 프라퍼티에서 발생한 모든 변경 사항을 반복한다. 여기서 원하는 네트워크 프라퍼티를 가져와 해당 프라퍼티에서 발생한 변경 사항으로 특정한 행동을 취할 수 있다.

다만, 속성 변화가 재연산에 의해 여러번 발생하거나 패킷 드롭으로 인해 발생하지 않을 수 있다. (정확하게 예측 시 한번, 예측이 잘못된 경우 두번... -> FixedUpdateNetwork 정확하게 이해하면 이해 될 것.)

변경되는 틱 직후에 실행됨.

### Network Behaviour
Render() 함수

-> 렌더링 관련된 부분은 여기서 처리하면 될 듯.
(override 해서 사용) 틱에 맞춰 실행됨.

### IBeforeUpdate

유니티의 Update와 유사하게 사용할 수 있다.

## Additional?

### 메인 로직 처리

### 메인 로직과 다른 부차적 로직(ex. 볼 발사 시 플레이어 색 변화)

## 실제 개발 방식

### 인풋 처리

INetworkInput을 상속받은 구조체에 인풋 받을 것을 몰아넣은 다음 InputManager에서 한번에 처리.




